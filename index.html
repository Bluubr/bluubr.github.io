<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¨ Pezutifier</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:           #0d0d12;
      --surface:      #17171f;
      --surface2:     #1f1f2d;
      --border:       #2c2c3f;
      --primary:      #7c5cbf;
      --primary-h:    #9370e0;
      --text:         #dcdcf0;
      --muted:        #7a7a99;
      --success:      #3cb887;
      --danger:       #e05555;
      --radius:       14px;
      --radius-sm:    8px;
    }

    html { scroll-behavior: smooth; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      padding-bottom: 4rem;
    }

    /* â”€â”€ Header â”€â”€ */
    .hero {
      text-align: center;
      padding: 3rem 1rem 2rem;
      background: linear-gradient(180deg, #1a0a3a 0%, transparent 100%);
    }
    .hero h1 {
      font-size: clamp(2rem, 6vw, 3.2rem);
      font-weight: 800;
      letter-spacing: -0.5px;
      background: linear-gradient(135deg, #a07ee8 20%, #e0b0ff 80%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .hero p { color: var(--muted); margin-top: .6rem; font-size: 1rem; }

    /* â”€â”€ Layout â”€â”€ */
    .container { max-width: 680px; margin: 0 auto; padding: 0 1rem; }

    /* â”€â”€ Card â”€â”€ */
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.4rem 1.6rem;
      margin-bottom: 1rem;
      transition: border-color .2s;
    }
    .card:focus-within { border-color: var(--primary); }
    .card-label {
      font-size: .72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .1em;
      color: var(--muted);
      margin-bottom: .9rem;
    }

    /* â”€â”€ Buttons â”€â”€ */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: .45rem;
      padding: .55rem 1.1rem;
      border-radius: var(--radius-sm);
      border: 1px solid transparent;
      font-size: .9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background .18s, transform .1s, box-shadow .18s;
      user-select: none;
    }
    .btn:active { transform: scale(.97); }
    .btn-primary {
      background: var(--primary);
      color: #fff;
    }
    .btn-primary:hover { background: var(--primary-h); box-shadow: 0 0 18px #7c5cbf66; }
    .btn-outline {
      background: transparent;
      color: var(--text);
      border-color: var(--border);
    }
    .btn-outline:hover { border-color: var(--primary); color: var(--primary); }
    .btn-success {
      background: var(--success);
      color: #fff;
      font-size: 1rem;
      padding: .65rem 1.5rem;
    }
    .btn-success:hover { filter: brightness(1.1); }
    .btn-big {
      width: 100%;
      justify-content: center;
      padding: .85rem;
      font-size: 1.05rem;
    }

    /* â”€â”€ File label â”€â”€ */
    .file-btn {
      display: inline-flex;
      align-items: center;
      gap: .45rem;
      padding: .55rem 1.1rem;
      border-radius: var(--radius-sm);
      border: 1px dashed var(--border);
      font-size: .9rem;
      font-weight: 600;
      cursor: pointer;
      color: var(--text);
      transition: border-color .18s, color .18s;
    }
    .file-btn:hover { border-color: var(--primary); color: var(--primary); }
    .file-name {
      font-size: .82rem;
      color: var(--muted);
      margin-left: .5rem;
    }

    /* â”€â”€ Color picker row â”€â”€ */
    .color-row { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .color-swatch {
      width: 44px; height: 44px;
      border-radius: 50%;
      border: 2px solid var(--border);
      overflow: hidden;
      cursor: pointer;
      transition: border-color .2s;
      flex-shrink: 0;
    }
    .color-swatch:hover { border-color: var(--primary); }
    .color-swatch input[type="color"] {
      width: 100%; height: 100%;
      border: none; outline: none;
      cursor: pointer;
      padding: 0;
      background: none;
    }
    .color-meta { font-size: .85rem; color: var(--muted); line-height: 1.6; }

    /* â”€â”€ Radio / Toggle â”€â”€ */
    .toggle-group { display: flex; gap: .6rem; flex-wrap: wrap; }
    .toggle-label {
      display: flex;
      align-items: center;
      gap: .5rem;
      padding: .5rem 1rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      cursor: pointer;
      font-size: .9rem;
      transition: border-color .18s, background .18s;
    }
    .toggle-label:has(input:checked) {
      border-color: var(--primary);
      background: #7c5cbf22;
      color: #c4a0ff;
    }
    .toggle-label input[type="radio"] { display: none; }

    /* â”€â”€ Text inputs â”€â”€ */
    .input-row { display: flex; gap: 1rem; flex-wrap: wrap; }
    .input-group { display: flex; flex-direction: column; gap: .35rem; flex: 1; min-width: 120px; }
    .input-group label { font-size: .78rem; color: var(--muted); font-weight: 600; }
    .input-group input[type="text"] {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-size: 1.1rem;
      font-weight: 700;
      padding: .5rem .8rem;
      width: 100%;
      transition: border-color .18s;
    }
    .input-group input[type="text"]:focus { outline: none; border-color: var(--primary); }

    /* â”€â”€ File row â”€â”€ */
    .file-row { display: flex; align-items: center; gap: .6rem; margin-bottom: .7rem; flex-wrap: wrap; }
    .file-row:last-child { margin-bottom: 0; }

    /* â”€â”€ Section hidden â”€â”€ */
    .hidden { display: none !important; }

    /* â”€â”€ Status â”€â”€ */
    #status {
      text-align: center;
      font-size: .9rem;
      color: var(--muted);
      margin: .8rem 0;
      min-height: 1.4em;
    }
    #status.ok { color: var(--success); }
    #status.err { color: var(--danger); }

    /* â”€â”€ Process button â”€â”€ */
    .process-wrap { margin: 1.2rem 0 .5rem; }

    /* â”€â”€ Result â”€â”€ */
    #resultSection { margin-top: 1.5rem; }
    #resultSection h2 {
      font-size: .72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .1em;
      color: var(--muted);
      margin-bottom: .9rem;
    }
    #outputCanvas {
      width: 100%;
      max-width: 100%;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      display: block;
    }
    .download-wrap { margin-top: 1rem; display: flex; justify-content: center; }

    /* â”€â”€ Spinner â”€â”€ */
    .spinner {
      display: inline-block;
      width: 16px; height: 16px;
      border: 2.5px solid transparent;
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin .7s linear infinite;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€ Responsive â”€â”€ */
    @media (max-width: 480px) {
      .card { padding: 1.1rem 1.1rem; }
      .toggle-group { flex-direction: column; }
    }
  </style>
</head>
<body>

<header class="hero">
  <h1>ğŸ¨ Pezutifier</h1>
  <p>Turn any image into a stylised card â€” right in your browser</p>
</header>

<main class="container">

  <!-- â”€â”€ Base Image â”€â”€ -->
  <div class="card">
    <div class="card-label">Base Image</div>
    <div style="display:flex;gap:.7rem;align-items:center;flex-wrap:wrap;">
      <button id="useDefaultBtn" class="btn btn-primary">âš¡ Use Default Base.png</button>
      <label class="file-btn">
        ğŸ“‚ Upload Custom
        <input type="file" id="baseFileInput" accept="image/*" hidden />
      </label>
      <span id="baseName" class="file-name">No image selected</span>
    </div>
  </div>

  <!-- â”€â”€ Color â”€â”€ -->
  <div class="card">
    <div class="card-label">Overlay Color</div>
    <div class="color-row">
      <label class="color-swatch" title="Click to pick a color">
        <input type="color" id="colorPicker" value="#d9d9d9" />
      </label>
      <div class="color-meta" id="colorMeta">Hex: #d9d9d9 &nbsp;|&nbsp; RGB: 217, 217, 217</div>
    </div>
  </div>

  <!-- â”€â”€ Content Type â”€â”€ -->
  <div class="card">
    <div class="card-label">Content Type</div>
    <div class="toggle-group">
      <label class="toggle-label">
        <input type="radio" name="contentType" value="letters" checked /> ğŸ”¤ Letters
      </label>
      <label class="toggle-label">
        <input type="radio" name="contentType" value="images" /> ğŸ–¼ï¸ Custom Images
      </label>
    </div>
  </div>

  <!-- â”€â”€ Letter Selection â”€â”€ -->
  <div class="card" id="letterSection">
    <div class="card-label">Letter Selection</div>
    <div class="input-row">
      <div class="input-group">
        <label for="leftLetter">Left Letter</label>
        <input type="text" id="leftLetter" value="A" maxlength="3" />
      </div>
      <div class="input-group">
        <label for="rightLetter">Right Letter</label>
        <input type="text" id="rightLetter" value="B" maxlength="3" />
      </div>
    </div>
  </div>

  <!-- â”€â”€ Image Selection â”€â”€ -->
  <div class="card hidden" id="imageSection">
    <div class="card-label">Image Selection</div>
    <div class="file-row">
      <label class="file-btn">
        ğŸ“‚ Select Left Image
        <input type="file" id="leftImageInput" accept="image/*" hidden />
      </label>
      <span id="leftImgName" class="file-name">No image selected</span>
    </div>
    <div class="file-row">
      <label class="file-btn">
        ğŸ“‚ Select Right Image
        <input type="file" id="rightImageInput" accept="image/*" hidden />
      </label>
      <span id="rightImgName" class="file-name">No image selected</span>
    </div>
  </div>

  <!-- â”€â”€ Process â”€â”€ -->
  <div class="process-wrap">
    <button id="processBtn" class="btn btn-primary btn-big">ğŸš€ Process Image</button>
  </div>
  <p id="status">Ready to processâ€¦</p>

  <!-- â”€â”€ Result â”€â”€ -->
  <div id="resultSection" class="hidden">
    <h2>Result</h2>
    <canvas id="outputCanvas"></canvas>
    <div class="download-wrap">
      <button id="downloadBtn" class="btn btn-success">â¬‡ï¸ Download PNG</button>
    </div>
  </div>

</main>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Pezutifier â€” browser-native image processing
   Mirrors the logic in src/main.py without tkinter or Pillow
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let baseImageEl   = null;   // HTMLImageElement for the base card
let blekCanvas    = null;   // Pre-loaded Blek overlay canvas
let leftImageFile = null;
let rightImageFile = null;

// â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const colorPicker    = document.getElementById('colorPicker');
const colorMeta      = document.getElementById('colorMeta');
const baseName       = document.getElementById('baseName');
const baseFileInput  = document.getElementById('baseFileInput');
const useDefaultBtn  = document.getElementById('useDefaultBtn');
const letterSection  = document.getElementById('letterSection');
const imageSection   = document.getElementById('imageSection');
const leftLetter     = document.getElementById('leftLetter');
const rightLetter    = document.getElementById('rightLetter');
const leftImageInput = document.getElementById('leftImageInput');
const rightImageInput= document.getElementById('rightImageInput');
const leftImgName    = document.getElementById('leftImgName');
const rightImgName   = document.getElementById('rightImgName');
const processBtn     = document.getElementById('processBtn');
const statusEl       = document.getElementById('status');
const resultSection  = document.getElementById('resultSection');
const outputCanvas   = document.getElementById('outputCanvas');
const downloadBtn    = document.getElementById('downloadBtn');

// â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Load an HTMLImageElement from a URL. */
function loadImg(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload  = () => resolve(img);
    img.onerror = () => reject(new Error(`Failed to load: ${src}`));
    img.src = src;
  });
}

/** Load an HTMLImageElement from a File object. */
function loadFile(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload  = () => { URL.revokeObjectURL(url); resolve(img); };
    img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Bad image file')); };
    img.src = url;
  });
}

/** Center-crop an image/canvas to a square. Returns a new canvas. */
function cropToSquare(src) {
  const sw = src.naturalWidth  || src.width;
  const sh = src.naturalHeight || src.height;
  const dim = Math.min(sw, sh);
  const sx  = (sw - dim) / 2;
  const sy  = (sh - dim) / 2;
  const c   = document.createElement('canvas');
  c.width = c.height = dim;
  c.getContext('2d').drawImage(src, sx, sy, dim, dim, 0, 0, dim, dim);
  return c;
}

/** Draw src into a new canvas of exact size (tw Ã— th). */
function resize(src, tw, th) {
  const c = document.createElement('canvas');
  c.width = tw; c.height = th;
  c.getContext('2d').drawImage(src, 0, 0, tw, th);
  return c;
}

function setStatus(msg, kind = '') {
  statusEl.textContent = msg;
  statusEl.className = kind;
}

// â”€â”€ Preload Blek.png â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(async () => {
  try {
    const img = await loadImg('src/images/Blek.png');
    const sq  = cropToSquare(img);
    blekCanvas = sq;
  } catch (e) {
    console.warn('Could not preload Blek.png:', e.message);
  }
})();

// â”€â”€ Event wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

colorPicker.addEventListener('input', () => {
  const hex = colorPicker.value;
  const r   = parseInt(hex.slice(1,3), 16);
  const g   = parseInt(hex.slice(3,5), 16);
  const b   = parseInt(hex.slice(5,7), 16);
  colorMeta.textContent = `Hex: ${hex}  |  RGB: ${r}, ${g}, ${b}`;
});

useDefaultBtn.addEventListener('click', async () => {
  try {
    baseImageEl = await loadImg('src/images/Base.png');
    baseName.textContent = 'Base.png (default)';
    setStatus('Default base image loaded âœ“', 'ok');
  } catch {
    setStatus('Could not load src/image/Base.png â€” try uploading it manually.', 'err');
  }
});

baseFileInput.addEventListener('change', async () => {
  const file = baseFileInput.files[0];
  if (!file) return;
  baseImageEl = await loadFile(file);
  baseName.textContent = file.name;
  setStatus(`Custom base loaded: ${file.name}`, 'ok');
});

document.querySelectorAll('input[name="contentType"]').forEach(r => {
  r.addEventListener('change', () => {
    const useImages = r.value === 'images';
    letterSection.classList.toggle('hidden',  useImages);
    imageSection.classList.toggle('hidden',  !useImages);
  });
});

leftImageInput.addEventListener('change',  () => {
  leftImageFile = leftImageInput.files[0] || null;
  leftImgName.textContent = leftImageFile ? leftImageFile.name : 'No image selected';
});
rightImageInput.addEventListener('change', () => {
  rightImageFile = rightImageInput.files[0] || null;
  rightImgName.textContent = rightImageFile ? rightImageFile.name : 'No image selected';
});

processBtn.addEventListener('click', processImage);
downloadBtn.addEventListener('click', () => {
  const a = document.createElement('a');
  a.href = outputCanvas.toDataURL('image/png');
  a.download = 'pezutified.png';
  a.click();
});

// â”€â”€ Core Image Processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * colorZut â€” mirrors colorZut() in main.py
 * 1. Alpha-composite a solid color overlay (alpha=150) over the base image.
 * 2. Subtract the Blek mask channel-by-channel (including alpha) to shape the card.
 */
function colorZut(baseCanvas, r, g, b) {
  const w = baseCanvas.width;
  const h = baseCanvas.height;

  // â”€â”€ 1. Draw base â†’ get pixels â”€â”€
  const tmp = document.createElement('canvas');
  tmp.width = w; tmp.height = h;
  const ctx = tmp.getContext('2d', { willReadFrequently: true });
  ctx.drawImage(baseCanvas, 0, 0);
  const baseData = ctx.getImageData(0, 0, w, h).data;

  // â”€â”€ 2. Alpha-composite color overlay (straight alpha) â”€â”€
  // Mirrors PIL Image.alpha_composite(base, overlay_RGBA_with_alpha_150)
  const a_ov  = 150 / 255;
  const blended = new Uint8ClampedArray(w * h * 4);
  for (let i = 0; i < baseData.length; i += 4) {
    const a_b   = baseData[i + 3] / 255;
    const a_out = a_ov + a_b * (1 - a_ov);
    if (a_out > 0) {
      blended[i]   = Math.round((r * a_ov + baseData[i]   * a_b * (1 - a_ov)) / a_out);
      blended[i+1] = Math.round((g * a_ov + baseData[i+1] * a_b * (1 - a_ov)) / a_out);
      blended[i+2] = Math.round((b * a_ov + baseData[i+2] * a_b * (1 - a_ov)) / a_out);
    }
    blended[i+3] = Math.round(a_out * 255);
  }

  // â”€â”€ 3. Resize Blek to wÃ—h â”€â”€
  const blekResized = resize(blekCanvas, w, h);
  const blekCtx     = blekResized.getContext('2d', { willReadFrequently: true });
  const blekData    = blekCtx.getImageData(0, 0, w, h).data;

  // â”€â”€ 4. Subtract Blek (all 4 channels) â†’ mirrors ImageChops.subtract â”€â”€
  const resultData = new ImageData(w, h);
  for (let i = 0; i < blended.length; i += 4) {
    resultData.data[i]   = Math.max(0, blended[i]   - blekData[i]);
    resultData.data[i+1] = Math.max(0, blended[i+1] - blekData[i+1]);
    resultData.data[i+2] = Math.max(0, blended[i+2] - blekData[i+2]);
    resultData.data[i+3] = Math.max(0, blended[i+3] - blekData[i+3]);
  }

  ctx.putImageData(resultData, 0, 0);
  return tmp;
}

/**
 * tiltLetter â€” mirrors tilt_letter() in main.py
 *
 * Draws a white letter centred in a temp canvas, then applies the same
 * 2D affine shear transform as PIL's Image.Transform.AFFINE.
 *
 * PIL uses an inverse-mapping matrix (destâ†’src). To get the canvas
 * forward-mapping matrix we invert each PIL matrix analytically:
 *
 *   PIL left  (1.0, 0.0,  90, âˆ’0.5, 1.0, 230) â†’
 *     canvas setTransform(1.0,  0.5,  0.0,  1.0, âˆ’90Â·s, âˆ’275Â·s)
 *
 *   PIL right (1.0, 0.0, 200,  0.5, 1.0,  90) â†’
 *     canvas setTransform(1.0, âˆ’0.5,  0.0,  1.0, âˆ’200Â·s,  10Â·s)
 *
 * s = refW / 744  (744 px is the reference Base.png square side)
 */
function tiltLetter(letter, side, fontSize, refW) {
  const tempSize = Math.floor(fontSize * 2);
  const outW     = Math.floor(tempSize * 0.8);
  const outH     = Math.floor(tempSize * 1.2);
  const s        = refW / 744;

  // Draw letter centred in temp canvas
  const tempC = document.createElement('canvas');
  tempC.width = tempC.height = tempSize;
  const tCtx  = tempC.getContext('2d');
  tCtx.font         = `bold ${fontSize}px Arial, sans-serif`;
  tCtx.fillStyle    = 'white';
  tCtx.textAlign    = 'center';
  tCtx.textBaseline = 'middle';
  tCtx.fillText(letter, tempSize / 2, tempSize / 2);

  // Apply inverse-affine transform to output canvas
  const outC = document.createElement('canvas');
  outC.width  = outW;
  outC.height = outH;
  const oCtx = outC.getContext('2d');

  if (side === 'left') {
    oCtx.setTransform(1.0,  0.5, 0.0, 1.0, -90 * s, -275 * s);
  } else {
    oCtx.setTransform(1.0, -0.5, 0.0, 1.0, -200 * s,   10 * s);
  }
  oCtx.drawImage(tempC, 0, 0);
  oCtx.resetTransform();
  return outC;
}

/**
 * letterZut â€” mirrors letterZut() in main.py
 * Composites tilted letter canvases over the colorized card.
 */
function letterZut(l1, l2, colorized) {
  const w        = colorized.width;
  const h        = colorized.height;
  const fontSize = Math.floor(w * 0.4);

  const result = document.createElement('canvas');
  result.width  = w;
  result.height = h;
  const ctx = result.getContext('2d');
  ctx.drawImage(colorized, 0, 0);

  const leftC = tiltLetter(l1, 'left',  fontSize, w);
  ctx.drawImage(leftC, Math.floor(w * 0.05), Math.floor(h * 0.35 - 35));

  const rightC = tiltLetter(l2, 'right', fontSize, w);
  ctx.drawImage(rightC, Math.floor(w * 0.55), Math.floor(h * 0.35 - 35));

  return result;
}

/**
 * tiltImage â€” mirrors tilt_image() in main.py
 *
 * Resizes the source image to 244Ã—244, centres it in a temp canvas,
 * then applies the affine shear (inverted for canvas):
 *
 *   PIL left  (1.0, 0.0,  85, âˆ’0.415, 0.825, 270.5) â†’
 *     canvas setTransform(1.0,  0.5030, 0.0, 1.2121, âˆ’85Â·s, âˆ’370.636Â·s)
 *
 *   PIL right (0.99, 0.0, 212,  0.41, 0.82, 215) â†’
 *     canvas setTransform(1.01011, âˆ’0.50506, 0.0, 1.21954, âˆ’214.14Â·s, âˆ’155.13Â·s)
 */
async function tiltImage(file, side, targetSize, refW) {
  const RESIZE_TO = 244;
  const img       = await loadFile(file);
  const sq        = cropToSquare(img);
  const sized     = resize(sq, RESIZE_TO, RESIZE_TO);

  const tempSize  = Math.floor(targetSize * 2);
  const outW      = Math.floor(tempSize * 0.8);
  const outH      = Math.floor(tempSize * 1.2);
  const s         = refW / 744;

  // Place resized image inside temp canvas (mirrors paste_x / paste_y offsets)
  const pasteX = Math.floor((tempSize - RESIZE_TO) / 2) - 1;
  const pasteY = side === 'left'
    ? Math.floor((tempSize - RESIZE_TO) / 2) - 17
    : Math.floor((tempSize - RESIZE_TO) / 2) + 100;

  const tempC = document.createElement('canvas');
  tempC.width = tempC.height = tempSize;
  tempC.getContext('2d').drawImage(sized, pasteX, pasteY);

  // Apply inverse-affine transform
  const outC = document.createElement('canvas');
  outC.width  = outW;
  outC.height = outH;
  const oCtx = outC.getContext('2d');

  if (side === 'left') {
    oCtx.setTransform(1.0,     0.5030,   0.0, 1.2121,   -85 * s,     -370.636 * s);
  } else {
    oCtx.setTransform(1.01011, -0.50506, 0.0, 1.21954, -214.14 * s, -155.13 * s);
  }
  oCtx.drawImage(tempC, 0, 0);
  oCtx.resetTransform();
  return outC;
}

/**
 * addContentToImage â€” mirrors add_content_to_image(..., use_images=True)
 * Composites two tilted images over the colorized card.
 */
async function addContentToImage(colorized, img1File, img2File) {
  const w          = colorized.width;
  const h          = colorized.height;
  const targetSize = Math.floor(w * 0.5);

  const result = document.createElement('canvas');
  result.width  = w;
  result.height = h;
  const ctx = result.getContext('2d');
  ctx.drawImage(colorized, 0, 0);

  const leftC = await tiltImage(img1File, 'left',  targetSize, w);
  ctx.drawImage(leftC, Math.floor(w * -0.05), Math.floor(h * 0.25));

  const rightC = await tiltImage(img2File, 'right', targetSize, w);
  ctx.drawImage(rightC, Math.floor(w * 0.45), Math.floor(h * 0.27));

  return result;
}

// â”€â”€ Main orchestrator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function processImage() {
  // â”€â”€ Validate â”€â”€
  if (!baseImageEl) {
    setStatus('âš ï¸ Please select a base image first.', 'err');
    return;
  }
  if (!blekCanvas) {
    setStatus('âš ï¸ Blek.png is still loading â€” please wait a moment.', 'err');
    return;
  }

  const useImages = document.querySelector('input[name="contentType"]:checked').value === 'images';
  if (useImages && (!leftImageFile || !rightImageFile)) {
    setStatus('âš ï¸ Please select both left and right images.', 'err');
    return;
  }

  // â”€â”€ Processing â”€â”€
  processBtn.disabled = true;
  processBtn.innerHTML = '<span class="spinner"></span> Processingâ€¦';
  setStatus('Processingâ€¦');

  try {
    // Parse color
    const hex = colorPicker.value;
    const r   = parseInt(hex.slice(1,3), 16);
    const g   = parseInt(hex.slice(3,5), 16);
    const b   = parseInt(hex.slice(5,7), 16);

    // Crop base to square
    const baseSquare = cropToSquare(baseImageEl);
    const w = baseSquare.width;
    const h = baseSquare.height;

    // Step 1 â€” colorZut
    const colorized = colorZut(baseSquare, r, g, b);

    // Step 2 â€” add content
    let final;
    if (useImages) {
      final = await addContentToImage(colorized, leftImageFile, rightImageFile);
    } else {
      const l1 = leftLetter.value.trim()  || 'A';
      const l2 = rightLetter.value.trim() || 'B';
      final = letterZut(l1, l2, colorized);
    }

    // â”€â”€ Show result â”€â”€
    outputCanvas.width  = final.width;
    outputCanvas.height = final.height;
    outputCanvas.getContext('2d').drawImage(final, 0, 0);

    resultSection.classList.remove('hidden');
    resultSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    setStatus('âœ… Done! Scroll down to see your result.', 'ok');

  } catch (err) {
    console.error(err);
    setStatus('âŒ Error: ' + err.message, 'err');
  } finally {
    processBtn.disabled = false;
    processBtn.innerHTML = 'ğŸš€ Process Image';
  }
}
</script>
</body>
</html>
